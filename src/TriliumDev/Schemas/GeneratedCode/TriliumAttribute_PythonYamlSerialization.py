# --------------------------------------------------------------------------------
# |
# |  WARNING:
# |  This file was generated; any local changes will be overwritten during
# |  future invocations of the generator!
# |
# |  Generated by: <SimpleSchemaGenerator>/Plugins/Impl/PythonSerializationImpl.py
# |  Generated on: 2022-05-18 12:39:47.548326
# |
# --------------------------------------------------------------------------------
import copy
import sys

from collections import OrderedDict

import six

import CommonEnvironment
from CommonEnvironment.TypeInfo import Arity
from CommonEnvironment.TypeInfo.AnyOfTypeInfo import AnyOfTypeInfo
from CommonEnvironment.TypeInfo.ClassTypeInfo import ClassTypeInfo
from CommonEnvironment.TypeInfo.DictTypeInfo import DictTypeInfo
from CommonEnvironment.TypeInfo.GenericTypeInfo import GenericTypeInfo
from CommonEnvironment.TypeInfo.ListTypeInfo import ListTypeInfo

from CommonEnvironment.TypeInfo.FundamentalTypes.Serialization.PythonCodeVisitor import PythonCodeVisitor
from CommonEnvironment.TypeInfo.FundamentalTypes.Serialization.StringSerialization import StringSerialization

# <Unused import> pylint: disable = W0611
# <Unused import> pylint: disable = W0614
from CommonEnvironment.TypeInfo.FundamentalTypes.All import *               # <Wildcard import> pylint: disable = W0401

# <Standard import should be placed before...> pylint: disable = C0411

# ----------------------------------------------------------------------
import rtyaml

from CommonEnvironment.CallOnExit import CallOnExit
from CommonEnvironment import FileSystem
from CommonEnvironment.TypeInfo.FundamentalTypes.Serialization.YamlSerialization import YamlSerialization


# ----------------------------------------------------------------------
# <Method name "..." doesn't conform to PascalCase naming style> pylint: disable = C0103
# <Line too long> pylint: disable = C0301
# <Too many lines in module> pylint: disable = C0302
# <Wrong hanging indentation> pylint: disable = C0330

# <Too few public methods> pylint: disable = R0903
# <Too many public methods> pylint: disable = R0904
# <Too many branches> pylint: disable = R0912
# <Too many statements> pylint: disable = R0915


# ----------------------------------------------------------------------
class SerializationException(Exception):
    # ----------------------------------------------------------------------
    def __init__(self, ex_or_string):
        if isinstance(ex_or_string, six.string_types):
            super(SerializationException, self).__init__(ex_or_string)
        else:
            super(SerializationException, self).__init__(str(ex_or_string))

            self.__dict__ = copy.deepcopy(ex_or_string.__dict__)

    # ----------------------------------------------------------------------
    def __str__(self):
        result = super(SerializationException, self).__str__()

        if hasattr(self, "stack"):
            result += " [{}]".format(" -> ".join(self.stack))

        return result

    # ----------------------------------------------------------------------
    def __repr__(self):
        return CommonEnvironment.ObjectReprImpl(self)


class KeySerializationException(SerializationException):                    pass
class SerializeException(SerializationException):                           pass
class DeserializeException(SerializationException):                         pass


class DoesNotExist(object):                                                 pass


# ----------------------------------------------------------------------
# |
# |  Utility Methods
# |
# ----------------------------------------------------------------------
def Serialize(
    root,
    process_additional_data=False,
    always_include_optional=False,
    to_string=False,
):
    """Convenience method that serializes all top-level elements"""

    # No convenience conversions

    result = _CreatePythonObject(
        attributes=None,
    )

    this_result = Serialize_Attribute(
        root,
        is_root=True,
        process_additional_data=process_additional_data,
        always_include_optional=always_include_optional,

    )
    if this_result is not DoesNotExist:
        setattr(result, "Attribute", this_result)
    elif always_include_optional:
        setattr(result, "Attribute", None)

    this_result = Serialize_Attributes(
        root,
        is_root=True,
        process_additional_data=process_additional_data,
        always_include_optional=always_include_optional,

    )
    if this_result is not DoesNotExist:
        setattr(result, "Attributes", this_result)
    elif always_include_optional:
        setattr(result, "Attributes", [])

    if to_string:
        result = rtyaml.dump(result)

    return result


# ----------------------------------------------------------------------
def Deserialize(
    root,
    process_additional_data=False,
    always_include_optional=False,
):
    """Convenience method that deserializes all top-level elements"""

    if isinstance(root, six.string_types):
        if FileSystem.IsFilename(root):
            with open(root) as f:
                root = rtyaml.load(f)
        else:
            root = rtyaml.load(root)

    result = _CreatePythonObject(
        attributes=None,
    )

    this_result = Deserialize_Attribute(
        root,
        is_root=True,
        process_additional_data=process_additional_data,
        always_include_optional=always_include_optional,

    )
    if this_result is not DoesNotExist:
        setattr(result, "Attribute", this_result)
    elif always_include_optional:
        setattr(result, "Attribute", None)

    this_result = Deserialize_Attributes(
        root,
        is_root=True,
        process_additional_data=process_additional_data,
        always_include_optional=always_include_optional,

    )
    if this_result is not DoesNotExist:
        setattr(result, "Attributes", this_result)
    elif always_include_optional:
        setattr(result, "Attributes", [])

    return result


# ----------------------------------------------------------------------
def Serialize_Attribute(
    item,
    process_additional_data=False,
    always_include_optional=False,
    to_string=False,
    pretty_print=False,
    is_root=False,
):
    """Serializes 'Attribute' from a python object to a YAML object"""

    if not isinstance(item, list):
        if isinstance(item, dict) and "Attribute" in item:
            item = item["Attribute"]
        elif not isinstance(item, dict) and hasattr(item, "Attribute"):
            item = getattr(item, "Attribute")
        elif is_root:
            item = DoesNotExist

    try:
        try:
            item = Serializer().Attribute(
                item,
                process_additional_data=process_additional_data,
                always_include_optional=always_include_optional,
            )
        except:
            _DecorateActiveException("Attribute")
    except SerializationException:
        raise
    except Exception as ex:
        raise SerializeException(ex)

    if to_string and item not in [DoesNotExist, None]:
        item = rtyaml.dump(item)

    return item


# ----------------------------------------------------------------------
def Serialize_Attributes(
    items,
    process_additional_data=False,
    always_include_optional=False,
    to_string=False,
    pretty_print=False,
    is_root=False,
):
    """Serializes 'Attributes' from a python object to a YAML object"""

    if not isinstance(items, list):
        if isinstance(items, dict) and "Attributes" in items:
            items = items["Attributes"]
        elif not isinstance(items, dict) and hasattr(items, "Attributes"):
            items = getattr(items, "Attributes")
        elif is_root:
            items = DoesNotExist

    try:
        try:
            items = Serializer().Attributes(
                items,
                process_additional_data=process_additional_data,
                always_include_optional=always_include_optional,
            )

            if items is DoesNotExist:
                items = []
        except:
            _DecorateActiveException("Attributes")
    except SerializationException:
        raise
    except Exception as ex:
        raise SerializeException(ex)

    if to_string and items not in [DoesNotExist, None]:
        items = rtyaml.dump(items)

    return items


# ----------------------------------------------------------------------
def Deserialize_Attribute(
    item,
    process_additional_data=False,
    always_include_optional=False,
    is_root=False,
):
    """Deserializes 'Attribute' from a YAML object to a python object"""

    if isinstance(item, six.string_types):
        if FileSystem.IsFilename(item):
            with open(item) as f:
                item = rtyaml.load(f)
        else:
            item = rtyaml.load(item)

    if not isinstance(item, list):
        if isinstance(item, dict) and "Attribute" in item:
            item = item["Attribute"]
        elif not isinstance(item, dict) and hasattr(item, "Attribute"):
            item = getattr(item, "Attribute")
        elif is_root:
            item = DoesNotExist

    try:
        try:
            item = Deserializer().Attribute(
                item,
                process_additional_data=process_additional_data,
                always_include_optional=always_include_optional,
            )
        except:
            _DecorateActiveException("Attribute")
    except SerializationException:
        raise
    except Exception as ex:
        raise DeserializeException(ex)

    return item


# ----------------------------------------------------------------------
def Deserialize_Attributes(
    items,
    process_additional_data=False,
    always_include_optional=False,
    is_root=False,
):
    """Deserializes 'Attributes' from a YAML object to a python object"""

    if isinstance(items, six.string_types):
        if FileSystem.IsFilename(items):
            with open(items) as f:
                items = rtyaml.load(f)
        else:
            items = rtyaml.load(items)

    if not isinstance(items, list):
        if isinstance(items, dict) and "Attributes" in items:
            items = items["Attributes"]
        elif not isinstance(items, dict) and hasattr(items, "Attributes"):
            items = getattr(items, "Attributes")
        elif is_root:
            items = DoesNotExist

    try:
        try:
            items = Deserializer().Attributes(
                items,
                process_additional_data=process_additional_data,
                always_include_optional=always_include_optional,
            )

            if items is DoesNotExist:
                items = []
        except:
            _DecorateActiveException("Attributes")
    except SerializationException:
        raise
    except Exception as ex:
        raise DeserializeException(ex)

    return items


# ----------------------------------------------------------------------
# |
# |  Type Infos
# |
# ----------------------------------------------------------------------
_Attribute_TypeInfo_Contents                                                = OrderedDict([("id", GenericTypeInfo()), ("attr_type", GenericTypeInfo()), ("name", GenericTypeInfo()), ("value", GenericTypeInfo()), ("position", GenericTypeInfo()), ("is_inheritable", GenericTypeInfo())])

Attribute_TypeInfo                                                          = AnyOfTypeInfo([ClassTypeInfo(_Attribute_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_Attribute_TypeInfo_Contents, require_exact_match=False)])
Attribute_id_TypeInfo                                                       = StringTypeInfo(min_length=1)
Attribute_attr_type_TypeInfo                                                = EnumTypeInfo([ 'label', 'relation', 'template', ])
Attribute_name_TypeInfo                                                     = StringTypeInfo(min_length=1)
Attribute_value_TypeInfo                                                    = AnyOfTypeInfo([ StringTypeInfo(min_length=0), IntTypeInfo(), BoolTypeInfo(), FloatTypeInfo(), DateTimeTypeInfo() ])
Attribute_value_0_TypeInfo                                                  = StringTypeInfo(min_length=0)
Attribute_value_1_TypeInfo                                                  = IntTypeInfo()
Attribute_value_2_TypeInfo                                                  = BoolTypeInfo()
Attribute_value_3_TypeInfo                                                  = FloatTypeInfo()
Attribute_value_4_TypeInfo                                                  = DateTimeTypeInfo()
Attribute_position_TypeInfo                                                 = IntTypeInfo(min=0)
Attribute_is_inheritable_TypeInfo                                           = BoolTypeInfo()
Attributes_TypeInfo                                                         = AnyOfTypeInfo([ClassTypeInfo(_Attribute_TypeInfo_Contents, require_exact_match=False), DictTypeInfo(_Attribute_TypeInfo_Contents, require_exact_match=False)], arity=Arity.FromString('*'))

# ----------------------------------------------------------------------
# |
# |  Serializer
# |
# ----------------------------------------------------------------------
class Serializer(object):

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute(cls, item, always_include_optional, process_additional_data):
        if item in [DoesNotExist, None]:
            Attribute_TypeInfo.ValidateArity(None)
            return DoesNotExist

        if not process_additional_data:
            Attribute_TypeInfo.ValidateArity(item)

        result = cls._Attribute_Item(item, always_include_optional, process_additional_data)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_id(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_id_TypeInfo.ValidateArity(None)
            return DoesNotExist

        Attribute_id_TypeInfo.ValidateArity(item)

        result = cls._Attribute_id_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_attr_type(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_attr_type_TypeInfo.ValidateArity(None)
            return DoesNotExist

        Attribute_attr_type_TypeInfo.ValidateArity(item)

        result = cls._Attribute_attr_type_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_name(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        Attribute_name_TypeInfo.ValidateArity(item)

        result = cls._Attribute_name_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_value(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_value_TypeInfo.ValidateArity(None)
            return DoesNotExist

        Attribute_value_TypeInfo.ValidateArity(item)

        result = cls._Attribute_value_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_position(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_position_TypeInfo.ValidateArity(None)
            return DoesNotExist

        Attribute_position_TypeInfo.ValidateArity(item)

        result = cls._Attribute_position_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_is_inheritable(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_is_inheritable_TypeInfo.ValidateArity(None)
            return DoesNotExist

        Attribute_is_inheritable_TypeInfo.ValidateArity(item)

        result = cls._Attribute_is_inheritable_Item(item)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attributes(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            Attributes_TypeInfo.ValidateArity(None)
            return DoesNotExist

        if not process_additional_data:
            Attributes_TypeInfo.ValidateArity(items)

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._Attributes_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        return results

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_Item(cls, item, always_include_optional, process_additional_data):
        Attribute_TypeInfo.ValidateItem(
            item,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        result = _CreatePythonObject(
            attributes=None,
        )

        # id
        try:
            setattr(result, "id", cls.Attribute_id(
                cls._GetPythonAttribute(
                    item,
                    "id",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("id")

        # attr_type
        try:
            setattr(result, "attr_type", cls.Attribute_attr_type(
                cls._GetPythonAttribute(
                    item,
                    "attr_type",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("attr_type")

        # name
        try:
            setattr(result, "name", cls.Attribute_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("name")

        # value
        try:
            setattr(result, "value", cls.Attribute_value(
                cls._GetPythonAttribute(
                    item,
                    "value",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("value")

        # position
        try:
            setattr(result, "position", cls.Attribute_position(
                cls._GetPythonAttribute(
                    item,
                    "position",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("position")

        # is_inheritable
        try:
            setattr(result, "is_inheritable", cls.Attribute_is_inheritable(
                cls._GetPythonAttribute(
                    item,
                    "is_inheritable",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("is_inheritable")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"id", "attr_type", "name", "value", "position", "is_inheritable"},
            )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_id_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_id_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_attr_type_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_attr_type_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_name_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_Item(cls, item):
        for method_info in [
            cls._Attribute_value_0_Item,
            cls._Attribute_value_1_Item,
            cls._Attribute_value_2_Item,
            cls._Attribute_value_3_Item,
            cls._Attribute_value_4_Item,
        ]:
            if isinstance(method_info, tuple):
                potential_method, class_name = method_info
            else:
                potential_method = method_info
                class_name = None

            try:
                result = potential_method(item)

                if class_name is not None:
                    setattr(result, "_variant_type", class_name)

                return result
            except:
                pass

        raise SerializeException("The value cannot be converted to any of the supported variations")

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_0_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_value_0_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_1_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_value_1_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_2_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_value_2_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_3_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_value_3_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_4_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_value_4_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_position_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_position_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_is_inheritable_Item(cls, item):
        return YamlSerialization.SerializeItem(Attribute_is_inheritable_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attributes_Item(cls, item, always_include_optional, process_additional_data):
        Attributes_TypeInfo.ValidateItem(
            item,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        result = _CreatePythonObject(
            attributes=None,
        )

        # id
        try:
            setattr(result, "id", cls.Attribute_id(
                cls._GetPythonAttribute(
                    item,
                    "id",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("id")

        # attr_type
        try:
            setattr(result, "attr_type", cls.Attribute_attr_type(
                cls._GetPythonAttribute(
                    item,
                    "attr_type",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("attr_type")

        # name
        try:
            setattr(result, "name", cls.Attribute_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("name")

        # value
        try:
            setattr(result, "value", cls.Attribute_value(
                cls._GetPythonAttribute(
                    item,
                    "value",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("value")

        # position
        try:
            setattr(result, "position", cls.Attribute_position(
                cls._GetPythonAttribute(
                    item,
                    "position",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("position")

        # is_inheritable
        try:
            setattr(result, "is_inheritable", cls.Attribute_is_inheritable(
                cls._GetPythonAttribute(
                    item,
                    "is_inheritable",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("is_inheritable")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"id", "attr_type", "name", "value", "position", "is_inheritable"},
            )

        return result

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _ApplyAdditionalData(
        cls,
        source,
        dest,
        exclude_names,
    ):
        for name, child in [(k, v) for k, v in six.iteritems(source if isinstance(source, dict) else getattr(source, "__dict__", {})) if not k.startswith("_") and k not in exclude_names]:
            try:
                if isinstance(child, list):
                    children = []

                    for index, item in enumerate(child):
                        item_name = "Index {}".format(index)

                        try:
                            children.append(cls._CreateAdditionalDataItem(item_name, item))
                        except:
                            _DecorateActiveException(item_name)

                    setattr(dest, name, children)
                else:
                    setattr(dest, name, cls._CreateAdditionalDataItem(name, child))
            except:
                _DecorateActiveException(name)

    # ----------------------------------------------------------------------
    @classmethod
    def _RejectAdditionalData(cls, source, exclude_names):
        errors = []

        for name, child in [(k, v) for k, v in six.iteritems(source if isinstance(source, dict) else getattr(source, "__dict__", {})) if not k.startswith("_") and k not in exclude_names]:
            errors.append(name)

        if errors:
            raise Exception("The item contains unexpected children: {}".format(", ".join(['"{}"'.format(error) for error in errors])))

    # ----------------------------------------------------------------------
    @classmethod
    def _CreateAdditionalDataItem(cls, name, source):
        # The following types should be returned directly without additional conversion
        if isinstance(source, (int, float, str, bool)):
            return source

        assert not isinstance(source, list), source

        if not isinstance(source, dict):
            source = source.__dict__

        source_attribute_names = source.get("_attribute_names", set())

        attributes = OrderedDict()
        items = OrderedDict()

        for k, v in six.iteritems(source):
            if k.startswith("_"):
                continue

            if k in source_attribute_names:
                attributes[k] = v
            else:
                items[k] = v

        if len(items) == 1 and next(six.iterkeys(items)) == source.get("_text_attribute_name", None):
            return _CreatePythonObject(
                attributes=attributes,
                **{"simple_value": source[source["_text_attribute_name"]], "_text_attribute_name": "simple_value"},
            )

        result = _CreatePythonObject(
            attributes=attributes,
        )

        for k, v in six.iteritems(items):
            try:
                if isinstance(v, list):
                    new_items = []

                    for index, child in enumerate(v):
                        try:
                            new_items.append(cls._CreateAdditionalDataItem("item", child))
                        except:
                            _DecorateActiveException("Index {}".format(index))

                    setattr(result, k, new_items)
                else:
                    new_item = cls._CreateAdditionalDataItem(k, v)

                    setattr(result, k, new_item)
            except:
                _DecorateActiveException(k)

        return result

    # ----------------------------------------------------------------------
    @staticmethod
    def _GetPythonAttribute(
        item,
        attribute_name,
        is_optional=False,
    ):
        if not isinstance(item, dict):
            if hasattr(item, "__dict__"):
                item = item.__dict__
            else:
                item = {}

        value = item.get(attribute_name, DoesNotExist)
        if value is DoesNotExist and not is_optional:
            raise SerializeException("No items were found")

        return value


# ----------------------------------------------------------------------
class Object(object):
    def __init__(self):
        self._attribute_names = set()

    def __repr__(self):
        return CommonEnvironment.ObjectReprImpl(self)


# ----------------------------------------------------------------------
def _CreatePythonObject(
    attributes=None,
    **kwargs
):
    attributes = attributes or {}

    result = Object()

    for d in [attributes, kwargs]:
        for k, v in six.iteritems(d):
            setattr(result, k, v)

    for k in six.iterkeys(attributes):
        result._attribute_names.add(k)

    return result


# ----------------------------------------------------------------------
# |
# |  Deserializer
# |
# ----------------------------------------------------------------------
class Deserializer(object):

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute(cls, item, always_include_optional, process_additional_data):
        if item in [DoesNotExist, None]:
            Attribute_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Attribute_Item(item, always_include_optional, process_additional_data)

        if not process_additional_data:
            Attribute_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_id(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_id_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Attribute_id_Item(item)

        Attribute_id_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_attr_type(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_attr_type_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Attribute_attr_type_Item(item)

        Attribute_attr_type_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_name(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_name_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Attribute_name_Item(item)

        Attribute_name_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_value(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_value_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Attribute_value_Item(item)

        Attribute_value_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_position(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_position_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Attribute_position_Item(item)

        Attribute_position_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attribute_is_inheritable(cls, item):
        if item in [DoesNotExist, None]:
            Attribute_is_inheritable_TypeInfo.ValidateArity(None)
            return DoesNotExist

        result = cls._Attribute_is_inheritable_Item(item)

        Attribute_is_inheritable_TypeInfo.ValidateArity(result)

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def Attributes(cls, items, always_include_optional, process_additional_data):
        if items in [DoesNotExist, None, []]:
            Attributes_TypeInfo.ValidateArity(None)
            return DoesNotExist

        results = []

        for this_index, this_item in enumerate(items or []):
            try:
                results.append(cls._Attributes_Item(this_item, always_include_optional, process_additional_data))
            except:
                _DecorateActiveException("Index {}".format(this_index))

        if not process_additional_data:
            Attributes_TypeInfo.ValidateArity(results)

        return results

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_Item(cls, item, always_include_optional, process_additional_data):
        result = _CreatePythonObject(
            attributes=None,
        )

        # id
        try:
            setattr(result, "id", cls.Attribute_id(
                cls._GetPythonAttribute(
                    item,
                    "id",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("id")

        # attr_type
        try:
            setattr(result, "attr_type", cls.Attribute_attr_type(
                cls._GetPythonAttribute(
                    item,
                    "attr_type",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("attr_type")

        # name
        try:
            setattr(result, "name", cls.Attribute_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("name")

        # value
        try:
            setattr(result, "value", cls.Attribute_value(
                cls._GetPythonAttribute(
                    item,
                    "value",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("value")

        # position
        try:
            setattr(result, "position", cls.Attribute_position(
                cls._GetPythonAttribute(
                    item,
                    "position",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("position")

        # is_inheritable
        try:
            setattr(result, "is_inheritable", cls.Attribute_is_inheritable(
                cls._GetPythonAttribute(
                    item,
                    "is_inheritable",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("is_inheritable")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"id", "attr_type", "name", "value", "position", "is_inheritable"},
            )

        else:
            cls._RejectAdditionalData(
                item,
                exclude_names=["id", "attr_type", "name", "value", "position", "is_inheritable"],
            )

        Attribute_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_id_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_id_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_attr_type_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_attr_type_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_name_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_name_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_Item(cls, item):
        for method_info in [
            cls._Attribute_value_0_Item,
            cls._Attribute_value_1_Item,
            cls._Attribute_value_2_Item,
            cls._Attribute_value_3_Item,
            cls._Attribute_value_4_Item,
        ]:
            if isinstance(method_info, tuple):
                potential_method, class_name = method_info
            else:
                potential_method = method_info
                class_name = None

            try:
                result = potential_method(item)

                if class_name is not None:
                    setattr(result, "_variant_type", class_name)

                return result
            except:
                pass

        raise DeserializeException("The value cannot be converted to any of the supported variations")

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_0_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_value_0_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_1_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_value_1_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_2_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_value_2_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_3_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_value_3_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_value_4_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_value_4_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_position_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_position_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attribute_is_inheritable_Item(cls, item):
        return YamlSerialization.DeserializeItem(Attribute_is_inheritable_TypeInfo, item, **{})

    # ----------------------------------------------------------------------
    @classmethod
    def _Attributes_Item(cls, item, always_include_optional, process_additional_data):
        result = _CreatePythonObject(
            attributes=None,
        )

        # id
        try:
            setattr(result, "id", cls.Attribute_id(
                cls._GetPythonAttribute(
                    item,
                    "id",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("id")

        # attr_type
        try:
            setattr(result, "attr_type", cls.Attribute_attr_type(
                cls._GetPythonAttribute(
                    item,
                    "attr_type",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("attr_type")

        # name
        try:
            setattr(result, "name", cls.Attribute_name(
                cls._GetPythonAttribute(
                    item,
                    "name",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("name")

        # value
        try:
            setattr(result, "value", cls.Attribute_value(
                cls._GetPythonAttribute(
                    item,
                    "value",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("value")

        # position
        try:
            setattr(result, "position", cls.Attribute_position(
                cls._GetPythonAttribute(
                    item,
                    "position",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("position")

        # is_inheritable
        try:
            setattr(result, "is_inheritable", cls.Attribute_is_inheritable(
                cls._GetPythonAttribute(
                    item,
                    "is_inheritable",
                    is_optional=False,
                ),
            )
            )
        except:
            _DecorateActiveException("is_inheritable")

        # Additional data
        if process_additional_data:
            cls._ApplyAdditionalData(
                item,
                result,
                exclude_names={"id", "attr_type", "name", "value", "position", "is_inheritable"},
            )

        else:
            cls._RejectAdditionalData(
                item,
                exclude_names=["id", "attr_type", "name", "value", "position", "is_inheritable"],
            )

        Attributes_TypeInfo.ValidateItem(
            result,
            recurse=False,
            require_exact_match=not process_additional_data,
        )

        return result

    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    # ----------------------------------------------------------------------
    @classmethod
    def _ApplyAdditionalData(
        cls,
        source,
        dest,
        exclude_names,
    ):
        for name, child in [(k, v) for k, v in six.iteritems(source if isinstance(source, dict) else getattr(source, "__dict__", {})) if not k.startswith("_") and k not in exclude_names]:
            try:
                if isinstance(child, list):
                    children = []

                    for index, item in enumerate(child):
                        item_name = "Index {}".format(index)

                        try:
                            children.append(cls._CreateAdditionalDataItem(item_name, item))
                        except:
                            _DecorateActiveException(item_name)

                    setattr(dest, name, children)
                else:
                    setattr(dest, name, cls._CreateAdditionalDataItem(name, child))
            except:
                _DecorateActiveException(name)

    # ----------------------------------------------------------------------
    @classmethod
    def _RejectAdditionalData(cls, source, exclude_names):
        errors = []

        for name, child in [(k, v) for k, v in six.iteritems(source if isinstance(source, dict) else getattr(source, "__dict__", {})) if not k.startswith("_") and k not in exclude_names]:
            errors.append(name)

        if errors:
            raise Exception("The item contains unexpected children: {}".format(", ".join(['"{}"'.format(error) for error in errors])))

    # ----------------------------------------------------------------------
    @classmethod
    def _CreateAdditionalDataItem(cls, name, source):
        # The following types should be returned directly without additional conversion
        if isinstance(source, (int, float, str, bool)):
            return source

        assert not isinstance(source, list), source

        if not isinstance(source, dict):
            source = source.__dict__

        source_attribute_names = source.get("_attribute_names", set())

        attributes = OrderedDict()
        items = OrderedDict()

        for k, v in six.iteritems(source):
            if k.startswith("_"):
                continue

            if k in source_attribute_names:
                attributes[k] = v
            else:
                items[k] = v

        if len(items) == 1 and next(six.iterkeys(items)) == source.get("_text_attribute_name", None):
            return _CreatePythonObject(
                attributes=attributes,
                **{"simple_value": source[source["_text_attribute_name"]], "_text_attribute_name": "simple_value"},
            )

        result = _CreatePythonObject(
            attributes=attributes,
        )

        for k, v in six.iteritems(items):
            try:
                if isinstance(v, list):
                    new_items = []

                    for index, child in enumerate(v):
                        try:
                            new_items.append(cls._CreateAdditionalDataItem("item", child))
                        except:
                            _DecorateActiveException("Index {}".format(index))

                    setattr(result, k, new_items)
                else:
                    new_item = cls._CreateAdditionalDataItem(k, v)

                    setattr(result, k, new_item)
            except:
                _DecorateActiveException(k)

        return result

    # ----------------------------------------------------------------------
    @staticmethod
    def _GetPythonAttribute(
        item,
        attribute_name,
        is_optional=False,
    ):
        if not isinstance(item, dict):
            if hasattr(item, "__dict__"):
                item = item.__dict__
            else:
                item = {}

        value = item.get(attribute_name, DoesNotExist)
        if value is DoesNotExist and not is_optional:
            raise SerializeException("No items were found")

        return value


# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
def _DecorateActiveException(frame_desc):
    exception = sys.exc_info()[1]

    if not hasattr(exception, "stack"):
        setattr(exception, "stack", [])

    exception.stack.insert(0, frame_desc)

    # <The raise statement is not inside an except clause> pylint: disable = E0704
    raise


# ----------------------------------------------------------------------
def _ObjectToYaml(dumper, data):
    d = dict(data.__dict__)
    for k in list(six.iterkeys(d)):
        if k.startswith("_"):
            del d[k]

    return dumper.represent_dict(d)


rtyaml.Dumper.add_representer(Object, _ObjectToYaml)
